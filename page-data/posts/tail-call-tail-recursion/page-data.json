{"componentChunkName":"component---src-templates-post-template-tsx","path":"/posts/tail-call-tail-recursion","result":{"data":{"site":{"siteMetadata":{"title":"June"}},"markdownRemark":{"id":"3c366cd0-b637-5fb6-8063-086b147e2d82","excerpt":"꼬리 물기 최적화라고 합니다. 여러 블로그를 구경하다가 알게된 개념이었고, 알고리즘 문제 해결을 좋아하셔서 runtime 시간 최소화를 신경써야 하는 경우에 필수적으로 알아두어야 합니다. 지연 평가 (lazy evaluation) 느긋한 계산법(Lazy evaluation…","html":"<p>꼬리 물기 최적화라고 합니다. 여러 블로그를 구경하다가 알게된 개념이었고, 알고리즘 문제 해결을 좋아하셔서 runtime 시간 최소화를 신경써야 하는 경우에 필수적으로 알아두어야 합니다.</p>\n<h2 id=\"지연-평가-lazy-evaluation\" style=\"position:relative;\">지연 평가 (lazy evaluation)<a href=\"#%EC%A7%80%EC%97%B0-%ED%8F%89%EA%B0%80-lazy-evaluation\" aria-label=\"지연 평가 lazy evaluation permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>느긋한 계산법(Lazy evaluation)은 계산의 결과값이 필요할 때까지 계산을 늦추는 기법이다 ... 느긋하게 계산하면 필요없는 계산을 하지 않으므로 실행을 더 빠르게 할 수 있고, 복합 수식을 계산할 때 오류 상태를 피할 수 있고, 무한 자료 구조를 쓸 수 있고, 미리 정의된 것을 이용하지 않고 보통 함수로 제어 구조를 정의할 수 있다. - <a href=\"https://ko.wikipedia.org/wiki/%EB%8A%90%EA%B8%8B%ED%95%9C_%EA%B3%84%EC%82%B0%EB%B2%95\" target=\"_blank\" rel=\"noopener\">wiki</a></p>\n<p>여러 이점이 있지만 <code class=\"language-text\">불필요한 계산 안함</code> 이라는 이점이 제일 가시적입니다.</p>\n<h3 id=\"엄격한-평가strict-evaluation\" style=\"position:relative;\">엄격한 평가(strict evaluation)<a href=\"#%EC%97%84%EA%B2%A9%ED%95%9C-%ED%8F%89%EA%B0%80strict-evaluation\" aria-label=\"엄격한 평가strict evaluation permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>지연 평가의 반대인 엄격한 평가는 우리가 일반적으로 사용하는 use case 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token number\">.10000</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> index <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 chaining 연산은 filter가 25000번, map이 25000번, slice가 2번 돌게 됩니다. 코드는 간단하게 만들었지만 50002번이나 도는 엄청난 병목이 생기는 지점을 만들어냈습니다. 조금 만 더 생각을 해본다면 아래처럼 고칠 수 있겠죠.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 결과가 단계마다 값 별로 생겨남</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span><span class=\"token number\">.10000</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [1, 2, 3, 4]</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> index <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// [2, 4]</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">v</span> <span class=\"token operator\">=></span> v <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [20, 40]</span></code></pre></div>\n<p>slice 4, filter 4, map 2, 총 10번의 반복으로 종료됩니다.</p>\n<p>이러한 지연 평가 함수를 항상 고려하고, 순서를 바꿀 수 없는 상황 등의 이유로 임의로 만들기란 쉽지 않습니다.\n그래서 보통 lodash를 이용해 많이 만들곤 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 결과가 단계마다 실행 함수 별로 생겨남</span>\n<span class=\"token keyword\">const</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> _<span class=\"token punctuation\">.</span><span class=\"token function\">chain</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token comment\">// lodash에서 chain으로 묶으면 지연 평가 대상이 되고, 이후 value로 값을 꺼내 사용할 수 있음.</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span> <span class=\"token operator\">=></span> num <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num</span> <span class=\"token operator\">=></span> num <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// chain (0) -> filter (true) -> map (10) -> take (success, 10)</span>\n<span class=\"token comment\">// chain (1) -> filter (false)</span>\n<span class=\"token comment\">// chain (2) -> filter (true) -> map (12) -> take (success, 12)</span>\n<span class=\"token comment\">// chain (3) -> filter (false)</span>\n<span class=\"token comment\">// chain (4) -> filter (true) -> map (14) -> take (fail)</span>\n<span class=\"token comment\">// chain (5) -> filter (false)</span>\n<span class=\"token comment\">// chain (6) -> filter (true) -> map (16) -> take (fail)</span>\n<span class=\"token operator\">...</span><span class=\"token punctuation\">.</span></code></pre></div>\n<p>최종적으로는 결과값이 필요한 2개의 지연 평가 부분을 제외하고는 연산이 실행되지 않습니다.</p>\n<h2 id=\"지연-연산\" style=\"position:relative;\">지연 연산<a href=\"#%EC%A7%80%EC%97%B0-%EC%97%B0%EC%82%B0\" aria-label=\"지연 연산 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>지연 평가는 tail recursion 을 하는데 필요한 내용은 아니지만, 지연 연산에 대한 개념을 위해 정리해봤습니다.\n지연 연산은 지연 평가에서 연산을 바로 하지 않고 실제 실행이 되는 시점에 진행하는 것인데요, 연산자 만으로 지연 연산을 할 수 있도록 도와주는 연사자들이 있습니다. <code class=\"language-text\">||</code>, <code class=\"language-text\">&amp;&amp;</code>, <code class=\"language-text\">삼항연산자</code> 이 3가지 입니다.</p>\n<p>이 3가지 외의 연산을 사용하게 되면 연산들이 stack에 쌓이게 됩니다.</p>\n<h2 id=\"Tail-call\" style=\"position:relative;\">Tail call<a href=\"#Tail-call\" aria-label=\"Tail call permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수는 기본적으로 호출 후, 완료됐을 때 호출한 부분으로 돌아가기 위해 이전 공간을 stack에 쌓아둡니다. 그 이유는 <code class=\"language-text\">마저 할 일</code>이 남아있기 때문입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span>  <span class=\"token function-variable function\">fibo</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>n에 5를 넣었을 때 실행 컨텍스트의 순서는 어떻게 될까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fibo(5)\n  fibo(4)\n    fibo(3)\n      fibo(2)\n        fibo(1)\n          1\n        fibo(0)\n          0\n      fibo(1)\n        1\n    fibo(2)\n      fibo(1)\n        1\n      fibo(0)\n        0\n  fibo(3)\n    fibo(2)\n      fibo(1)\n        1\n      fibo(0)\n        0\n    fibo(1)\n      1</code></pre></div>\n<p>최대 depth는 5개가 됩니다. 만약 이 depth가 1000개, 100000개가 된다면 어떻게 될까요...??\n그렇기 때문에 마저 할 일을 없애서 원래 자리를 stack에 쌓지 않도록 하는 방법이 tail call 입니다.</p>\n<h2 id=\"Tail-call-optimize\" style=\"position:relative;\">Tail call optimize<a href=\"#Tail-call-optimize\" aria-label=\"Tail call optimize permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>함수가 return에서 호출된 뒤, 돌아왔을 때 아무런 할 일이 없으면 됩니다. 별도의 변수에 결과를 받아 return 하는 것 조차 할 일이 되므로 return에서 함수를 호출해줘야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 1번</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 2번</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">a</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span>b<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>둘 중 어떤 것이 tail call이 될까요? 답은 1번입니다. 2번은 다음 라인에서 1이 빼지기 때문. 결국 함수 호출 이후가 되기 때문에 stack에 메모리가 쌓이게 됩니다.</p>\n<p>tail call 방식은 stack을 쌓지 않고 재사용 하는 방식으로 언어 level로 지원하기도 합니다. 물론 js도 지원하지만 브라우저는 현재 ios만 지원하고 있는 상황입니다.</p>\n<h2 id=\"Tail-recursion\" style=\"position:relative;\">Tail recursion<a href=\"#Tail-recursion\" aria-label=\"Tail recursion permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>tail recursion은 tail call로 자기 자신의 함수를 호출하는 것을 말합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fibo <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> prevFibo <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> pprevFibo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> temp<span class=\"token punctuation\">;</span>\n  temp <span class=\"token operator\">=</span> prevFibo <span class=\"token operator\">+</span> pprevFibo<span class=\"token punctuation\">;</span>\n  pprevFibo <span class=\"token operator\">=</span> prevFibo<span class=\"token punctuation\">;</span>\n  prevFibo <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> n <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token operator\">?</span> prevFibo <span class=\"token operator\">:</span> <span class=\"token function\">fibo</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> prevFibo<span class=\"token punctuation\">,</span> pprevFibo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>그렇다면 처음에 만들었던 fibo함수와 비교해보겠습니다.</p>\n<p>우선 일반 fibo함수입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7f86ff5fff5a37bd66e27aa2a4272809/1a057/normal_fibo.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAByZuAD//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAIDAQAAAAAAAAAAAAAAABAhAAERgf/aAAgBAQABPyF05wasP//aAAwDAQACAAMAAAAQHO//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCq/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHRAAAgIBBQAAAAAAAAAAAAAAAREAIaEQMUFRcf/aAAgBAQABPxAABTMJK2P2X1mG1ONf/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"normal_fibo\"\n        title=\"normal_fibo\"\n        src=\"/static/7f86ff5fff5a37bd66e27aa2a4272809/7cc5e/normal_fibo.jpg\"\n        srcset=\"/static/7f86ff5fff5a37bd66e27aa2a4272809/e439a/normal_fibo.jpg 120w,\n/static/7f86ff5fff5a37bd66e27aa2a4272809/09b79/normal_fibo.jpg 240w,\n/static/7f86ff5fff5a37bd66e27aa2a4272809/7cc5e/normal_fibo.jpg 480w,\n/static/7f86ff5fff5a37bd66e27aa2a4272809/80e3c/normal_fibo.jpg 720w,\n/static/7f86ff5fff5a37bd66e27aa2a4272809/6a068/normal_fibo.jpg 960w,\n/static/7f86ff5fff5a37bd66e27aa2a4272809/1a057/normal_fibo.jpg 1026w\"\n        sizes=\"(max-width: 480px) 100vw, 480px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><code class=\"language-text\">fibo(40)</code>을 하니 1.8s이 걸리고, <code class=\"language-text\">fibo(50)</code>을 하니 브라우저가 멈춥니다...! 계속 기다려보니 약 3분뒤 성공했습니다.</p>\n<p>후...! 과연 tail recursion fibo함수는 어떨까요?</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 480px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/18d32f4158901f0a2a66d8e95d3f08e4/a207c/tail_fibo.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB5UwmrYj/xAAXEAADAQAAAAAAAAAAAAAAAAAAARAC/9oACAEBAAEFAqjU/8QAFREBAQAAAAAAAAAAAAAAAAAAABL/2gAIAQMBAT8BlL//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwGq/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRABAQEAAwAAAAAAAAAAAAAAAQARECEx/9oACAEBAAE/IQwl4bvt0bb/2gAMAwEAAgADAAAAENzv/8QAFhEBAQEAAAAAAAAAAAAAAAAAADFx/9oACAEDAQE/EJrT/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxAP/8QAHRABAAICAgMAAAAAAAAAAAAAAQAhEVExQWFxkf/aAAgBAQABPxBEVGu5ldHhlafsQxTUaGK9RTys/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"tail_fibo\"\n        title=\"tail_fibo\"\n        src=\"/static/18d32f4158901f0a2a66d8e95d3f08e4/7cc5e/tail_fibo.jpg\"\n        srcset=\"/static/18d32f4158901f0a2a66d8e95d3f08e4/e439a/tail_fibo.jpg 120w,\n/static/18d32f4158901f0a2a66d8e95d3f08e4/09b79/tail_fibo.jpg 240w,\n/static/18d32f4158901f0a2a66d8e95d3f08e4/7cc5e/tail_fibo.jpg 480w,\n/static/18d32f4158901f0a2a66d8e95d3f08e4/80e3c/tail_fibo.jpg 720w,\n/static/18d32f4158901f0a2a66d8e95d3f08e4/6a068/tail_fibo.jpg 960w,\n/static/18d32f4158901f0a2a66d8e95d3f08e4/a207c/tail_fibo.jpg 1040w\"\n        sizes=\"(max-width: 480px) 100vw, 480px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><code class=\"language-text\">fibo(100)</code>의 결과가 0.005s 소요됩니다. maximum call stack size 직전까지 사용하는 <code class=\"language-text\">fibo(6593)</code>은 0.006s 소요됩니다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\">마무리<a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>메모리 문제는 알고리즘에서 특히 많이 신경써야 하지만 비단 알고리즘 뿐만 아니라 실전인 서비스 코드에서 더 많이 신경써야 합니다.\n간단한 api call과 데이터 맵핑만 하던 일상에서도 이러한 최적화 기법들을 잊지 말아야 합니다.</p>","frontmatter":{"title":"Tail call과 Tail recursion","date":"February 08, 2022","tags":["javascript","tailcall","tailrecursion"]}}},"pageContext":{"slug":"/posts/tail-call-tail-recursion","previous":{"fields":{"slug":"/posts/when-use-usecallback"},"frontmatter":{"title":"useCallback은 언제 사용해야 할까?"}},"next":{"fields":{"slug":"/posts/raffle"},"frontmatter":{"title":"나이키 인스타 tracking 사이드 프로젝트"}}}},"staticQueryHashes":["1576648375","1963346411"]}