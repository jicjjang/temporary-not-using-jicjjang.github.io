{"componentChunkName":"component---src-templates-post-template-tsx","path":"/posts/javascript-optimize-7","result":{"data":{"site":{"siteMetadata":{"title":"June"}},"markdownRemark":{"id":"7bb7c9f3-2b00-5340-9621-e36b862a722f","excerpt":"가장 많이 쓰이며, 프론트 엔지니어에게 필수인 비동기 통신 요청인 Ajax에 대해 알아보겠습니다 7. Ajax 비동기적으로 데이터를 주고 받아서 페이지 부하를 최대한 줄일 수 있는\n고성능 javascript의 초석인 Ajax에 대해 알아보겠습니다. 7-…","html":"<p>가장 많이 쓰이며, 프론트 엔지니어에게 필수인 비동기 통신 요청인 Ajax에 대해 알아보겠습니다</p>\n<h2 id=\"7-Ajax\" style=\"position:relative;\">7. Ajax<a href=\"#7-Ajax\" aria-label=\"7 Ajax permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>비동기적으로 데이터를 주고 받아서 페이지 부하를 최대한 줄일 수 있는\n고성능 javascript의 초석인 Ajax에 대해 알아보겠습니다.</p>\n<h3 id=\"7-1-데이터-전송\" style=\"position:relative;\">7-1. 데이터 전송<a href=\"#7-1-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1\" aria-label=\"7 1 데이터 전송 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ol>\n<li>XMLHttpRequest</li>\n<li>동적 &#x3C;script> 태그 삽입</li>\n<li>iframe</li>\n<li>Comet</li>\n<li>Multipart XHR</li>\n</ol>\n<p>5종류의 기능을 주로 사용하지만, iframe이나 Comet은 데이터 전송 용도로 사용한다기엔 무리가 있으므로 제외합니다.</p>\n<p>보통 jQuery의 ajax 기능을 이용해서 많이 사용하는 XMLHttpRequest에는 readyState라는 중요한 요소가 있습니다.\n전송중일 경우, 즉 스트리밍을 하는 동안에 readyState 값의 변화가 있다는 점입니다. 그 말은 스트리밍이 진행중일 때를\n캐치할 수 있다는 것이지요.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> req <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XMLHttpRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nreq<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">onreadystatechange</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">===</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>             <span class=\"token comment\">// 일부 데이터를 받았음. 전송 진행중.</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>req<span class=\"token punctuation\">.</span>readyState <span class=\"token operator\">===</span> <span class=\"token number\">4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>      <span class=\"token comment\">// 데이터 전송이 끝남.</span>\n    <span class=\"token comment\">// ...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">...</span></code></pre></div>\n<p>또한 GET방식으로 데이터 요청 시 데이터는 캐시가 되기 때문에 같은 데이터를 여러번 가져 올 경우 성능이 향상됩니다.\n(물론 가져온 데이터를 저장해서 사용하는 것이 가장 효율적입니다.)</p>\n<p>GET방식은 URL과 매개변수의 길이가 2,048자로 제한이 되기 때문에 사용 시 유의해야 합니다.\n(길이를 넘는다면 POST를 사용해야 합니다.)</p>\n<hr>\n<p>동적 &#x3C;script> 태그 삽입은 다른 도메인에 있는 서버에 데이터를 요청할 수 없다는 XHR의 단점을 극복할 수 있는\n방법입니다. 그래서 해킹이라고 볼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> scriptA <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nscriptA<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'address'</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'head'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>scriptA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>데이터를 받는 부분은 어떻게 해야할까요?</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> scriptA <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'script'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nscriptA<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'http://test.com/lib.js'</span><span class=\"token punctuation\">;</span>\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">getElementsByTagName</span><span class=\"token punctuation\">(</span><span class=\"token string\">'head'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>scriptA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">jsonCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// lib.js file</span>\n<span class=\"token function\">jsonCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token operator\">:</span> <span class=\"token string\">'success'</span><span class=\"token punctuation\">,</span> value<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>a<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> b<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>이렇게 호출할 때 callback 함수를 미리 생성해 놓고, 불러온 파일 내부에서 callback 함수를 실행시키는 것입니다.\n하지만 이 방법은 누군가 인지하고 callback 함수를 구현한 javascript 파일을 불러온다면 문제가 발생할 여지가 있기에\n데이터가 변할 수 있는 기능에 추천하지 않습니다.</p>\n<hr>\n<p>Multipart XHR은 기본 XHR 통신과 거의 같습니다. 다만, n개의 파일을 가져올 때 n번의 XHR요청을 보내는 것이 아니라\n1번의 요청을 보내면서 n개의 파일을 하나로 합쳐서 받는 것입니다.</p>\n<p>서버에서 base64 인코딩을 한 결과 값들을 특정 구분자로 이어붙여서 리턴하면 그 값을 javascript에서 다시 잘라서 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">$images = array(&#39;a.jpg&#39;, &#39;b.jpg&#39;, &#39;c.jpg&#39;);\nforeach ($images as $image) {\n  $image_fh = fopen($image, &#39;r&#39;);\n  $image_data = fread($image_fh, filesize($image));\n  fclose($image_fh);\n  $payloads[] = base64_encode($image_data);\n}\n\n$newline = chr(1);  // 구분자. unicode 1\n\necho implode($newline, $payloads);  // $newline을 구분자로 $payloads를 연결시킴.</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">splitImages</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">imageString</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> imageData <span class=\"token operator\">=</span> imageString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">'\\u001'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// unicode 1. 구분자를 기준으로 나눔.</span>\n  <span class=\"token keyword\">var</span> imageElement<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> doc <span class=\"token operator\">=</span> document<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> len <span class=\"token operator\">=</span> imageData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    imageElement <span class=\"token operator\">=</span> doc<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'img'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    imageElement<span class=\"token punctuation\">.</span>src <span class=\"token operator\">=</span> <span class=\"token string\">'data:image/jpeg;base64,'</span> <span class=\"token operator\">+</span> imageData<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    doc<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>imageElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이미지 뿐만 아니라 같은 확장자의 파일 (css, js, png, jpg, html...)모두 가능합니다.</p>\n<p>큰 단점은 캐시가 되지 않는다는 점입니다. 파일 형식으로 불러오는 것이 아니라 string형식으로 가져오기 때문입니다.</p>\n<hr>\n<p>XHR을 사용할 때 속도는 GET이 POST보다 빠릅니다. GET은 기본적으로 1개의 패킷을, POST는 2개의 패킷을 사용하는데\n데이터 양이 많으면 패킷을 하나 더 쓴다는 단점이 희석되기 때문에 데이터 양이 많을 때에는 POST가 적합합니다.</p>\n<h3 id=\"7-2-데이터-포맷\" style=\"position:relative;\">7-2. 데이터 포맷<a href=\"#7-2-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%8F%AC%EB%A7%B7\" aria-label=\"7 2 데이터 포맷 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>데이터 포맷의 종류로는</p>\n<ol>\n<li>XML</li>\n<li>XPath</li>\n<li>JSON</li>\n<li>JSON-P</li>\n<li>HTML</li>\n<li>Custom Format</li>\n</ol>\n<p>6가지가 있습니다.</p>\n<p>이제는 거의 사용을 하지 않는 XML, XPath는 제외하겠습니다. 이들은 사용에 있어서 모호함이 있기 때문에\n지양됩니다. (코드를 관리하는 방법이 3가지이기 때문에 애매합니다.)</p>\n<p>최근 가장 널리 사용되는 포맷인 JSON은 객체와 배열의 문법을 가볍게 파싱할 수 있습니다.\neval로도 쉽게 파싱할 수 있으나, 보안의 위협이 될 수 있으므로 JSON.parse 메서드를 사용해야 합니다.</p>\n<p>JSON-P는 XHR로 데이터를 받았을 때, JSON이 string으로 오는 이슈를 해결하기 위해 사용됩니다.\nJSON 데이터를 전달받은 즉시 JSON 형식으로 사용하기 위해선 데이터를 callback함수로 감싸야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">parseJSON</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> username<span class=\"token operator\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> username<span class=\"token operator\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>id<span class=\"token operator\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> username<span class=\"token operator\">:</span> <span class=\"token string\">'...'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>JSON과 마찬가지로 네이티브 코드인 JSON-P는 파일 크기가 조금 더 늘어나는 단점이 있으나, 파싱 시간이 줄어들기 때문에\n속도가 JSON보다 빠릅니다.</p>\n<p>JSON-P의 단점은 파싱할 수 없는 데이터를 받았을 때 발생합니다. 파싱 불가능한 형식의 response가 온다면\n에러가 발생할 수 있습니다.</p>\n<p>HTML은 XML과 비슷할 정도로 복잡한 포맷입니다. 그렇기 때문에 직접적으로 서버에서 응답을 주는 것은 최소한으로 줄여야 합니다.</p>\n<p>Custom Format은 a:junseok;jicjjang12@gmail.com; b:aa:aa@gmail.com; .... 처럼\n사용자가 직접 만든 문법을 사용하는 방식인데, split으로 간단하게 자르는 형식이기 때문에 속도는 매우 빠릅니다.\n(이 또한 보안상 이슈가 될 수 있으므로 간단하고 문제될 일 없는 데이터에만 사용하길 권장합니다.)</p>\n<h3 id=\"7-3-Ajax-성능-가이드\" style=\"position:relative;\">7-3. Ajax 성능 가이드<a href=\"#7-3-Ajax-%EC%84%B1%EB%8A%A5-%EA%B0%80%EC%9D%B4%EB%93%9C\" aria-label=\"7 3 Ajax 성능 가이드 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4 id=\"Ajax의-성능을-끌어올리기-위해선-응답을-캐시하도록-HTTP-Header를-설정해야-합니다\" style=\"position:relative;\">Ajax의 성능을 끌어올리기 위해선 응답을 캐시하도록 HTTP Header를 설정해야 합니다.<a href=\"#Ajax%EC%9D%98-%EC%84%B1%EB%8A%A5%EC%9D%84-%EB%81%8C%EC%96%B4%EC%98%AC%EB%A6%AC%EA%B8%B0-%EC%9C%84%ED%95%B4%EC%84%A0-%EC%9D%91%EB%8B%B5%EC%9D%84-%EC%BA%90%EC%8B%9C%ED%95%98%EB%8F%84%EB%A1%9D-HTTP-Header%EB%A5%BC-%EC%84%A4%EC%A0%95%ED%95%B4%EC%95%BC-%ED%95%A9%EB%8B%88%EB%8B%A4\" aria-label=\"Ajax의 성능을 끌어올리기 위해선 응답을 캐시하도록 HTTP Header를 설정해야 합니다 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>얼마의 기간동안 지니고 있어도 되는지를 파악하고 해당 Expires를 설정하여 브라우저에 저장합니다.\n해당 날짜가 지나면 Cache의 값 대신 서버로 요처을 보냅니다.</p>\n<h4 id=\"클라이언트-측에서-가져온-데이터를-로컬에-저장해-재요청을-줄입니다\" style=\"position:relative;\">클라이언트 측에서 가져온 데이터를 로컬에 저장해 재요청을 줄입니다.<a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%B8%A1%EC%97%90%EC%84%9C-%EA%B0%80%EC%A0%B8%EC%98%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EB%A1%9C%EC%BB%AC%EC%97%90-%EC%A0%80%EC%9E%A5%ED%95%B4-%EC%9E%AC%EC%9A%94%EC%B2%AD%EC%9D%84-%EC%A4%84%EC%9E%85%EB%8B%88%EB%8B%A4\" aria-label=\"클라이언트 측에서 가져온 데이터를 로컬에 저장해 재요청을 줄입니다 permalink\" class=\"autolink-headers-- after\"><svg aria-hidden=\"true\" height=\"20\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"20\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h4>\n<p>로컬 스토리지에 URL을 키값으로 하는 데이터를 저장합니다. 그러면 키값에 대한 고민이 해결되고\n데이터를 쉽게 로컬 스토리지에 저장할 수 있습니다. 로컬 스토리지에 값이 없을 때에만 서버로 요청을 보냅니다.</p>\n<hr>\n<p>이번 장은 여기까지 입니다.\nXML은 널리, 많이 사용되지만 파싱에 많은 시간이 소모되는 단점이 있습니다. 이미 널리 사용되었기 때문에\n이전 데이터를 모두 수정하기에 힘든 부분이 많습니다. 이제부터라도 저장되는 데이터는 JSON 형식으로 사용하는 것이\n필수적입니다.</p>","frontmatter":{"title":"자바스크립트 성능 최적화 7","date":"May 19, 2017","tags":["javascript","performance"]}}},"pageContext":{"slug":"/posts/javascript-optimize-7","previous":{"fields":{"slug":"/posts/javascript-optimize-4"},"frontmatter":{"title":"자바스크립트 성능 최적화 4"}},"next":{"fields":{"slug":"/posts/javascript-optimize-6"},"frontmatter":{"title":"자바스크립트 성능 최적화 6"}}}},"staticQueryHashes":["1576648375","1963346411"]}